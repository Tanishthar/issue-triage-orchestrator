from typing import Tuple, List
import re
import textwrap

def extract_repro_steps(issue_text: str, max_steps: int = 5) -> List[str]:
    """
    Heuristic extraction of repro steps from issue text:
    - Split into lines/sentences, look for action keywords (click, open, run, start, navigate, reproduce).
    - If not found, return 1-2 best sentences (first sentences).
    """
    if not issue_text:
        return []

    # split by newlines first (preserve user bullet points)
    lines = [ln.strip() for ln in issue_text.splitlines() if ln.strip()]
    candidate_steps = []

    # helper: sentence-split a long line
    def to_sentences(s: str):
        # simple sentence split
        return re.split(r'(?<=[.!?])\s+', s)

    keywords = ["click", "open", "run", "start", "navigate", "press", "type", "login", "reproduce", "steps", "install", "build"]

    # collect explicit bullets / enumerated steps
    for ln in lines:
        if re.match(r'^\d+[\.\)]', ln) or ln.startswith("-") or ln.startswith("*"):
            # strip leading bullet
            text = re.sub(r'^[\-\*\d\.\)\s]+', '', ln).strip()
            if text:
                candidate_steps.append(text)
        else:
            # check for keywords in the line
            low = ln.lower()
            if any(k in low for k in keywords):
                # break into sentences and add
                for s in to_sentences(ln):
                    s = s.strip()
                    if s:
                        candidate_steps.append(s)

    # fallback: split first 2 sentences of full text
    if not candidate_steps:
        sents = to_sentences(" ".join(lines))
        candidate_steps = [s.strip() for s in sents if s.strip()][:max_steps]

    # limit to max_steps
    return candidate_steps[:max_steps]


def propose_fix_sketch(severity: str, repro_steps: List[str], repo_readme: str = "") -> Tuple[str, str]:
    """
    Produce a short prose fix sketch and a failing pytest test skeleton.
    Returns: (fix_sketch_text, failing_test_code)
    - fix_sketch_text explains root cause hypothesis + recommended change.
    - failing_test_code is a small pytest test that asserts the problematic behavior (intentionally failing).
    """
    # Simple rules to produce fix sketch based on severity and repro steps
    if not repro_steps:
        repro_summary = "Unable to reliably extract repro steps from the issue text."
    else:
        repro_summary = " â†’ ".join(repro_steps[:3])

    severity_note = f"Severity: {severity}" if severity else "Severity: unknown"

    # Hypothesis: simple mapping of keywords to causes
    cause_hyp = "unknown root cause"
    if any("crash" in s.lower() or "exception" in s.lower() for s in repro_steps):
        cause_hyp = "unhandled exception or nil/None dereference during startup path"
    elif any("slow" in s.lower() or "lag" in s.lower() for s in repro_steps):
        cause_hyp = "inefficient algorithm or blocking I/O on main thread"
    elif any("login" in s.lower() for s in repro_steps):
        cause_hyp = "authentication/session initialization bug"
    else:
        cause_hyp = "unexpected state handling in feature code"

    fix_sketch = textwrap.dedent(f"""
    Repro summary: {repro_summary}
    {severity_note}

    Hypothesis:
      The issue is likely caused by {cause_hyp}. To validate and fix quickly:
      1) Add a focused unit test that reproduces the failing behavior (see attached test skeleton).
      2) Run that test to confirm failure and reproduce stacktrace.
      3) Add guards / input validation and/or catch the exception at the caller boundary.
      4) Add a regression test to CI to prevent future regressions.

    Suggested code changes (high-level):
      - Add validation checks where inputs are parsed / used.
      - Replace direct dereference with safe checks or try/except to produce friendly error messages.
      - If this is concurrency-related, introduce locking or move blocking I/O to background tasks.

    Notes:
      - This is a sketch to guide the first quick iteration; further debugging with logs/stacktrace is recommended.
    """).strip()

    # Create a failing pytest skeleton. Keep it generic and safe.
    test_code = textwrap.dedent(f"""
    import pytest

    def test_regression_sample():
        \"\"\"Failing test skeleton generated by orchestrator for repro: {repro_summary}\"\"\"
        # TODO: Replace the following with real calls to the repo functions.
        # This is intentionally failing to serve as a canary/regression test.
        assert 1 == 2
    """).lstrip()

    return fix_sketch, test_code
